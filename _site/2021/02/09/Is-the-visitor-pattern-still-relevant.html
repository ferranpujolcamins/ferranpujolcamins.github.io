<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Is the visitor pattern still relevant? | Ferran Pujol Camins</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Is the visitor pattern still relevant?" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In this post I’ll talk about the visitor pattern and I will try to answer the question: is it still relevant? To find the answer, I’ll explore sum and existential types: what they are and what they are useful for (spoiler alert: you already know them, just with a different name)." />
<meta property="og:description" content="In this post I’ll talk about the visitor pattern and I will try to answer the question: is it still relevant? To find the answer, I’ll explore sum and existential types: what they are and what they are useful for (spoiler alert: you already know them, just with a different name)." />
<link rel="canonical" href="http://localhost:4000/2021/02/09/Is-the-visitor-pattern-still-relevant.html" />
<meta property="og:url" content="http://localhost:4000/2021/02/09/Is-the-visitor-pattern-still-relevant.html" />
<meta property="og:site_name" content="Ferran Pujol Camins" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-02-09T00:00:00+01:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021/02/09/Is-the-visitor-pattern-still-relevant.html"},"headline":"Is the visitor pattern still relevant?","dateModified":"2021-02-09T00:00:00+01:00","datePublished":"2021-02-09T00:00:00+01:00","url":"http://localhost:4000/2021/02/09/Is-the-visitor-pattern-still-relevant.html","description":"In this post I’ll talk about the visitor pattern and I will try to answer the question: is it still relevant? To find the answer, I’ll explore sum and existential types: what they are and what they are useful for (spoiler alert: you already know them, just with a different name).","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Ferran Pujol Camins" /></head>
<body><header class="site-header">

    <div class="wrapper"><a class="site-title" rel="author" href="/">Ferran Pujol Camins</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger"><a class="page-link" href="/resume/">Resume</a></div>
        </nav></div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Is the visitor pattern still relevant?</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-02-09T00:00:00+01:00" itemprop="datePublished">Feb 9, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>In this post I’ll talk about the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> and I will try to answer the question: <em>is it still relevant?</em> To find the answer, I’ll explore sum and existential types: what they are and what they are useful for (spoiler alert: you already know them, just with a different name).</p>

<p>Although I focus on C++, most of the reasoning can be easily transported to other languages.</p>

<h2 id="the-problem">The problem</h2>

<p>According to the <a href="https://en.wikipedia.org/wiki/Design_Patterns">gang of four book</a>, the visitor pattern allows you to:</p>

<blockquote>
  <p>Represent an operation to be performed on the elements of an object structure […] without changing the classes of elements on which it operates.</p>
</blockquote>

<p>If we only consider what’s explicitly stated in this definition, one could say that the visitor pattern just consists in iterating
on a data structure and process each element with a function<sup><a href="#footnote-a">[a]</a></sup>.</p>

<p>However, when we talk about the visitor pattern there’s two implicit assumptions:</p>
<ol>
  <li>Our data structure contains heterogeneous objects that share a common interface.</li>
  <li>Our function needs to know the specific runtime type of each object in the structure.</li>
</ol>

<p>In other words, we face an additional problem: how can our function know the specific runtime type of an object under an interface?
This is an orthogonal problem to that of how to traverse a data structure, yet, in the visitor pattern both are intermixed<sup><a href="#footnote-b">[b]</a></sup>.</p>

<h3 id="the-naive-solution">The naive solution</h3>

<p>So we want to know the specific runtime type of an object under an interface. How can we do that?</p>

<p>The naive solution to this problem is to add a virtual method to the base class of our objects for each operation that needs to
know what is the specific runtime type of our objects. This is problematic because for each such operation
we need to add a new method to <strong>each</strong> subclass of our base class. This breaks the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open-closed principle</a>: we need to modify
our classes each time we want to add an external operation that works on them, so our classes can’t be closed for modification.
It also breaks the <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">dependency inversion principle</a>, since our classes need to depend on every concrete operation.</p>

<p>Another tempting approach is to use <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. As we’ll see on the next section, the visitor pattern forces us to add one virtual method to our class hierarchy. Although this is not too bad, with <code class="language-plaintext highlighter-rouge">dynamic_cast</code> we can do even better: we don’t need to modify our class hierarchy at all.
The main drawback of <code class="language-plaintext highlighter-rouge">dynamic_cast</code> is performance: it’s slower than the two virtual calls we need for the visitor pattern. The usage of <code class="language-plaintext highlighter-rouge">dynamic_cast</code> instead of the visitor pattern is highly despised on the internet. However, in my opinion, if performance is not an issue it’s a perfectly valid solution.</p>

<p>You can read in more detail about the problems and tradeoffs of these naive solutions and also about the visitor pattern in general in <a href="https://gieseanw.wordpress.com/2018/12/29/stop-reimplementing-the-virtual-table-and-start-using-double-dispatch/">this thorough article</a> by Andy G.</p>

<h2 id="double-dispatch-to-the-rescue">Double dispatch to the rescue</h2>

<p>As we hinted in the previous section, the less expensive (but still safe) way to determine the runtime type of an object is to use virtual calls.
Following this idea, we see that if an object of A wants to know the runtime type of an object B, A has to call a virtual method on object B.
The question is, how do we send the type information back to A? Easy, we just call a method of A from B:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AbstractClass</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="n">Operation</span><span class="o">*</span> <span class="n">operation</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Operation</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">AbstractClass</span><span class="o">*</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We ask `object` to call us back so we can discover its type.</span>
        <span class="c1">// We get back the result value we computed in the corresponding Operation::accept method.</span>
        <span class="k">return</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type B</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type C</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractClass</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="n">Operation</span><span class="o">*</span> <span class="n">operation</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="c1">// When an Operation visits us, we visit it back.</span>
        <span class="c1">// Since here we now `this` is of type `B*`,</span>
        <span class="c1">// The call to accept is statically resolved to the appropriate overload.</span>
        <span class="c1">// From the call to accept we get back the result of the computation</span>
        <span class="c1">// that Operation has performed, we have to return it back.</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractClass</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">accept</span><span class="p">(</span><span class="n">Operation</span><span class="o">*</span> <span class="n">operation</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">();</span>
    
    <span class="n">Operation</span> <span class="n">operation</span><span class="p">;</span>

    <span class="c1">// Prints 0 1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span>
            <span class="o">&lt;&lt;</span> <span class="n">operation</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This technique is called <em>single</em> (dynamic) <em>dispatch</em>, because we use one virtual call to <code class="language-plaintext highlighter-rouge">AbstractClass::accept</code> to determine the runtime type of our object. <code class="language-plaintext highlighter-rouge">Operation</code> is usually also called the <em>Visitor</em>.</p>

<p>If we wanted to add another operation, we would need to add a new method <code class="language-plaintext highlighter-rouge">int accept(OtherOperation* operation)</code> method to our class hierarchy, which is exactly what we want to avoid. To fix this, the trick is to abstract over the operations (or visitors) so we only need to add one accept method to our class hierarchy no matter how many operations we have:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;memory&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Operation</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AbstractVisitor</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractVisitor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AbstractClass</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">AbstractVisitor</span><span class="o">*</span> <span class="n">visitor</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Operation1</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractVisitor</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">AbstractClass</span><span class="o">*</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We ask `object` to call us back so we can discover its type.</span>
        <span class="c1">// We get back the result value we computed in the corresponding A::accept method.</span>
        <span class="n">object</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type B</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type C</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
  <span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Operation2</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractVisitor</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">char</span> <span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">AbstractClass</span><span class="o">*</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We ask `object` to call us back so we can discover its type.</span>
        <span class="c1">// We get back the result value we computed in the corresponding A::accept method.</span>
        <span class="n">object</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type B</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sc">'b'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">C</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Compute something when `object` is of type C</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>
    <span class="p">}</span>
    
  <span class="nl">private:</span>
    <span class="kt">char</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractClass</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">AbstractVisitor</span><span class="o">*</span> <span class="n">visitor</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="c1">// When an Operation visits us, we visit it back.</span>
        <span class="c1">// Since here we now `this` is of type `B*`,</span>
        <span class="c1">// The call to accept is statically resolved to the appropriate overload.</span>
        <span class="c1">// From the call to accept we get back the result of the computation</span>
        <span class="c1">// that Operation has performed, we need to return it back.</span>
        <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractClass</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">accept</span><span class="p">(</span><span class="n">AbstractVisitor</span><span class="o">*</span> <span class="n">visitor</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">visitor</span><span class="o">-&gt;</span><span class="n">accept</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">();</span>
    
    <span class="n">Operation1</span> <span class="n">operation1</span><span class="p">;</span>
    <span class="n">Operation2</span> <span class="n">operation2</span><span class="p">;</span>

    <span class="c1">// Prints 0 1</span>
    <span class="c1">//        b c</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">operation1</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span>
            <span class="o">&lt;&lt;</span> <span class="n">operation1</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
            <span class="o">&lt;&lt;</span> <span class="n">operation2</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span>
            <span class="o">&lt;&lt;</span> <span class="n">operation2</span><span class="p">.</span><span class="n">computeSomethingWith</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Different operations might need to compute different result values of different type for each visited element. Thus, the <code class="language-plaintext highlighter-rouge">AbstractVisitor::accept</code> methods can’t return int anymore. Furthermore, we can’t make <code class="language-plaintext highlighter-rouge">AbstractVisitor</code> a template class because it has virtual methods.
This is the reason we need to store the result value in a field of the visitor instance this time.</p>

<p>This technique is called <a href="https://en.wikipedia.org/wiki/Double_dispatch"><em>double</em> (dynamic) <em>dispatch</em></a>: we have the virtual call from the visitor to the element, and a virtual call back from the element to the visitor.</p>

<p>When you add to the mix a way to traverse a data structure with this double dispatch technique you get what’s usually called <em>the visitor pattern</em>.</p>

<p>The question here is: why would you want to know the specific runtime type of an object under an interface? Isn’t the whole point of dynamic polymorphism to forget about specific types and focus on the abstraction? To answer this question, let’s talk about <em>sum types</em> and <em>existential types</em>.</p>

<h2 id="sum-and-existential-types">Sum and Existential types</h2>

<p><em><a href="https://en.wikipedia.org/wiki/Tagged_union">Sum types</a></em> are data types that hold one single value at a time, out of a predefined finite list of values (or <em>cases</em>). Also, with each case, a value of a predefined type is stores. Think of an enum, but each enum case has predefined type, and along the enum case, an instance of the appropriate type is stored. For example, in Rust we can write:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">TwoIntsOrStringOrNothing</span> <span class="p">{</span>
        <span class="nf">AnInt</span><span class="p">(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">),</span> <span class="c">// The `AnInt` case holds two integers, or equivalently, holds a value of the tuple type (isize, isize)</span>
        <span class="nf">AString</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span> <span class="c">// The `AString` case holds a String</span>
        <span class="n">Nothing</span> <span class="c">// A case can have no associated data</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><em>Existential types</em> (or just <em>existential</em> for short) are like sum types, but there’s no predefined list of what values they can hold. You can think of existential types as an infinite sum of types<sup><a href="#ref-quantified-types-as-products-and-sums">[1]</a></sup>, i.e. an enum that can hold one case at a time, out of an infinite collection of possible types!</p>

<p>An existential it’s not very useful if we don’t limit the types it can hold: if we have a value of an unknown type, which could be any type, what can we do with it? Can we call the method <code class="language-plaintext highlighter-rouge">foo()</code> in this type? We don’t know. Can this type be copied? We don’t know, because it could be any type. This is why existentials are usually limited to hold values of types that conform to a certain interface. Thus, we can have an existential that holds “printable types”, so at least we know we can get a string representing the value it holds. For example, in Rust we can write:</p>
<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Define a trait (or interface)</span>
<span class="k">trait</span> <span class="n">Printable</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">stringify</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// A function that takes an existential type whose values must be Printable</span>
<span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span> <span class="n">Printable</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// We can call stringify, because we know that values of our existential implement at least this interface,</span>
    <span class="c">// alttough we can't know the concrete type we are working with.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">a</span><span class="nf">.stringify</span><span class="p">());</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Note that even though we have limited what concrete types an existential can hold, the number is still infinite, because you can’t know how many types conforming to the interface a user of your library will write.</p>

<p>Since we know all the possible types a sum type can hold, the compiler just needs to allocate as much memory as the biggest type needs (plus a little more to store what case we are in). This means that sum types can be allocated on the stack. On the other hand, since we don’t know what types an existential will hold, we can’t put an upper bound on its memory footprint. Thus, the value that an existential types holds is usually allocated on the heap. And I say usually, because in Rust there are several kinds of existential types, some of which can be allocated on the stack<sup><a href="#ref-existential-type-in-rust">[2]</a></sup>.</p>

<p>The definition of existential types might have rung a bell with you. In fact existential types are in some sense similar to <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)#Subtyping">subtype polymorphism</a><sup><a href="#ref-oop-vs-type-classes">[3]</a></sup>: with subtype polymorphism, whenever I have a variable of type <code class="language-plaintext highlighter-rouge">BaseClass*</code> I can store any instance of <strong>any</strong> subclass of <code class="language-plaintext highlighter-rouge">BaseClass*</code>. Likewise, with existential types, whenever I have a variable of type “Existential of <code class="language-plaintext highlighter-rouge">SomeInterface</code>”, I can store any object of <strong>any</strong> type that implements <code class="language-plaintext highlighter-rouge">SomeInterface</code>.</p>

<h3 id="when-to-use-sum-types-over-existential-types">When to use Sum types over Existential types?</h3>

<p>Why would anyone use sum types? At first glance they seem like a weaker version of existential types: while I can hold values of an infinite collection of types in an existential, with a sum type I can only hold values of a finite predefined collection of types. It turns out, that this characteristic of sum types it’s actually their strength<sup><a href="#footnote-c">[c]</a></sup>. Sum types allow us to model a fixed finite number of possibilities and treat each one of them <strong>specifically</strong>. Most compilers either issue a warning or error when trying to build a program if a function that reads a value of a sum type doesn’t cover all its cases, which helps catching mistakes at build time.</p>

<p>On the other hand, existentials allow us to be completely oblivious to concrete types, as long as they implement some interface. Thus, we are forced to treat types <strong>uniformly</strong>.</p>

<p>Sum types allow us to model choice, or the existence of several known possibilities. Existential types allow us to abstract over the details (what concrete implementation of an interface we are using).</p>

<h3 id="this-sounds-interesting-what-does-this-look-on-c">This sounds interesting. What does this look on C++?</h3>

<p>As we discussed above, C++ has subtype polymorphism (a pointer to a base class can hold an object of any subclass), which is equivalent to existential types.</p>

<p>C++ didn’t use to have <strong>safe</strong> support for sum types: enums can’t have associated data, and using unions is asking for trouble<sup><a href="#ref-the-joys-and-pains-of-unrestricted-unions">[4]</a></sup>.</p>

<h3 id="and-what-does-all-this-have-to-do-with-the-visitor-pattern">And what does all this have to do with the visitor pattern?</h3>

<p>So in C++ we didn’t have safe sum types. What could you do when you wanted to model choice or a finite set of possibilities?
Well, you (ab)used existentials (i.e. subtype polymorphism, i.e. an abstract class with a subclass for each case). As we said in the previous section, one of the reasons you would want to use a sum type is to treat each one of its cases specifically. In this case, this translates to determine the concrete runtime type of an object pointed by a base class pointer. Does this problem sound familiar? This is exactly the problem that led us to <a href="#double-dispatch-to-the-rescue">visitor pattern</a>!</p>

<p>It turns out that the visitor pattern was develop to cope with the lack of support for sum types in classic OOP languages like Java and C++.</p>

<h3 id="modern-c">Modern C++</h3>

<p>As you might have guessed by my usage of the past tense in the previous section, nowadays C++ has support for safe sum types! Since C++17 we have <code class="language-plaintext highlighter-rouge">std::variant</code>. Thanks to the <a href="https://en.cppreference.com/w/cpp/utility/variant/visit"><code class="language-plaintext highlighter-rouge">visit</code></a> function (and some obscure template meta-programming) we can handle each case of a variant like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">...;</span>

<span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">overloaded</span> <span class="p">{</span>
            <span class="p">[](</span><span class="kt">double</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">fixed</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">},</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">},</span>
            <span class="p">[](</span><span class="k">auto</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arg</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">},</span> <span class="c1">// "default" case</span>
        <span class="p">},</span> <span class="n">v</span><span class="p">);</span>
</code></pre></div></div>

<p>However, this solution is far from perfect. It’s not totally straightforward (template meta-programming, remember?). For example, if you forget to add a lambda for a case, the compiler spits a long error that apparently doesn’t have anything to do with a missing case.</p>

<p>Nonetheless, from my point of view, as of C++17, the answer to the question</p>
<blockquote>
  <p>Is the visitor pattern still relevant?</p>
</blockquote>

<p>is <strong>no</strong>.</p>

<p>99% of times, there’s no reason to use the visitor pattern (other than dealing with legacy code)<sup><a href="#footnote-d">[d]</a></sup>.</p>

<h2 id="final-thoughts">Final thoughts</h2>

<p>The visitor pattern is one of the 23 classic design patterns described in the <a href="https://en.wikipedia.org/wiki/Design_Patterns">gang of four book</a>. Design patterns offer known solutions to design problems following classic object oriented principles. They are reusable in different situations and help us identify and separate design complexity from complexity in our domain. Design patterns improve communication since they are known solutions that developers can identify and recognize.</p>

<p>However, as we’ve seen with the visitor pattern, they can become obsolete. Programming languages evolve, our collective knowledge as developers does too. New tools, techniques, ideas and paradigms appear. And all these things can make endemic problems and challenges disappear, and with them, the solutions that were designed to spare us from their pain.</p>

<p>Therefore, we must not blindly use design patterns (or any other established doctrine). We must periodically re-visit and challenge our ideas, study them under new perspectives. We have to listen to new ideas, discuss them and be truly and honestly open to have our mind changed. But, most importantly, we must always do this respectfully, and acknowledging that there are as many valid point of views, as people in this planet.</p>

<h2 id="notes">Notes</h2>

<ol class="nestedList spacedList letterList">
    <li id="footnote-a" class="ref">
        Maybe the data structure has more than one sensible way
        in which it can be iterated, or maybe we need to abstract over the specific structure we are iterating on.
        In these situations the <a href="https://en.wikipedia.org/wiki/Iterator_pattern">iterator pattern</a> comes in handy.
    </li>
    <li id="footnote-b" class="ref">
        These two problems were intermixed probably because for some data structures you need to know the runtime type of an object
        in order to know what is the next object you should visit. For example, consider the following binary tree representation: 
        <pre><code>// Abstract class
class Tree {};
class Empty: public Tree {};
class Branch: public Tree {
    Tree* leftBranch;
    Tree* rightBranch;
};</code></pre>
        When writing an iterator, given an object of type <code>Tree*</code> we need to know whether it's an instance of <code>Empty</code>
        or an instance of <code>Branch</code> in order to know what are (if any) the next elements of the tree that we have to visit.
    </li>
    <li id="footnote-c" class="ref">
        Plus they can be stack-allocated, remember!
    </li>
    <li id="footnote-d" class="ref">
        <a href="https://en.wikipedia.org/wiki/Serialization">Serialization</a> is an example where the visitor pattern can be useful.
        When writing serialization code, you want to be able to work with any <code>Serializable</code> type, thus you use existential types.
        However, you might not want to force every <code>Serializable</code> subclass to contain their serialization code. Maybe you want
        one single function elsewhere that takes a <code>Serializable*</code>, checks what specific case we are dealing with (like you would do with a sum type) and calls the appropriate serialization code. This way the serialization code is as decoupled from your classes as possible.
        You don't really want to write a sum type, because it could be a huge sum type that you have to change every time you make a class
        serializable. Also, you are not modeling a finite choice, it really make sense to use existentials. But you need to know the specific type under the abstraction. Thus, in this situation the visitor pattern is the way to go.
    </li>
</ol>

<h2 id="references">References</h2>

<ol class="nestedList">
    <li id="ref-quantified-types-as-products-and-sums" class="ref">
        <a href="https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Quantified_Types_as_Products_and_Sums">Quantified types as products and sums</a> <small>(en.wikibooks.org/wiki/Haskell)</small>
    </li>
    <li id="ref-existential-type-in-rust" class="ref">
        <a href="https://varkor.github.io/blog/2018/07/03/existential-types-in-rust.html">Existential types in Rust</a> <small>(varkor.github.io)</small>
    </li>
    <li id="ref-oop-vs-type-classes" class="ref">
        <a href="https://wiki.haskell.org/OOP_vs_type_classes#OO_class_always_corresponds_to_a_haskell_class_.2B_a_related_haskell_existential_.28John_Meacham.29">OOP vs type classes</a> <small>(wiki.haskell.org)</small>
    </li>
    <li id="ref-the-joys-and-pains-of-unrestricted-unions" class="ref">
        <a href="https://faouellet.github.io/unrestricted-unions/">The joys and pains of unrestricted unions</a> <small>(faouellet.github.io)</small>
    </li>
</ol>

<h2 id="further-reading">Further reading</h2>

<ul>
  <li><a href="https://www.haskellforall.com/2021/01/the-visitor-pattern-is-essentially-same.html">The visitor pattern is essentially the same thing as Church encoding</a> <small>(haskellforall.com)</small></li>
  <li><a href="https://blog.ploeh.dk/2018/06/25/visitor-as-a-sum-type/">Visitor as a sum type</a> <small>(blog.ploeh.dk)</small></li>
  <li><a href="https://bartoszmilewski.com/2015/01/13/simple-algebraic-data-types/">Simple Algebraic Data Types</a> <small>(bartoszmilewski.com)</small></li>
  <li><a href="https://chadaustin.me/2015/07/sum-types/">Sum Types Are Coming: What You Should Know</a> <small>(chadaustin.me)</small></li>
  <li><a href="https://stackoverflow.com/questions/870919/why-are-haskell-algebraic-data-types-closed">Why are Haskell algebraic data types “closed”?</a> 
<small>(stackoverflow.com)</small></li>
</ul>

  </div><a class="u-url" href="/2021/02/09/Is-the-visitor-pattern-still-relevant.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Ferran Pujol Camins</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Ferran Pujol Camins</li><li><a class="u-email" href="mailto:me@ferranpujolcamins.cat">me@ferranpujolcamins.cat</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ferranpujolcamins"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ferranpujolcamins</span></a></li><li><a href="https://www.twitter.com/ferranpujolca"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">ferranpujolca</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I&#39;m a versatile software developer with a mathematics background who has developed his professional career as an iOS developer. I&#39;m now looking for new professional challenges as a C++ developer. I&#39;m comfortable solving new problems and learning new things. I&#39;ve contributed to several open source projects in different languages. I know C++, Rust and Swift, among other languages. My skills include mathematics, algorithmics, functional programming, category theory and basic electronics.
 </p>
      </div>
    </div>

    <div class="footer-license-wrapper">
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">ferranpujolcamins.cat</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://www.ferranpujolcamins.cat" property="cc:attributionName" rel="cc:attributionURL">Ferran Pujol Camins</a>.
        <br/>
        The content of this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
        <br />
        Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://github.com/ferranpujolcamins/ferranpujolcamins.github.io" rel="dct:source">https://github.com/ferranpujolcamins/ferranpujolcamins.github.io</a>
    </div>

  </div>

</footer>
</body>

</html>
